# 第三章 语言基础

## 语法

1. JS 是区分大小写
2. **标识符**(函数、变量、属性、函数参数的名称)，必须以下划线*或者字母开头，可以包含下划线*、字母、数字（这里的字母不仅是英文字母，可以是 Unicode 的字母字符，所以 js 可以用中文做变量名）
3. 注释
   1. `\\`单行注释
   2. `\**\`多行注释
4. 严格模式，看着像是字符串，但其实是预处理指令"use strict";
   1. 加在脚本的第一行，对整个脚本启用
   2. 加在函数内部的第一行，只对本函数启用
5. 语句：可以没有分号，但最好还是用;结尾
6. 变量声明
   1. var ES6 之前的语法
   2. let ES6 新语法
   3. const ES6 新语法
7. 数据类型，6 种简单数据类型（原始类型），一种复杂类型
   - 简单类型
     - Undefined
     - Null
     - Boolean
     - Number
     - String
     - Symbol
   - 复杂类型 Object
8. 操作符，可用于操作数据值的操作符，包括数学操作符（如加、减）、位操作符、关系操作符和相等操作符等
9. 语句
10. 函数

## 变量

js 本身是动态类型，因此声明的一个变量可以用来存储任意类型的值

### var

使用 var 操作符定义的变量会成为包含它的函数的局部变量

```js
function test() {
  var message = "hi"; // 局部变量
}
test();
console.log(message); // 出错！
```

省略 var 将会导致函数里面的定义的变量变成全局变量

```JS
function test() {
 message = "hi"; // 全局变量
}
test();
console.log(message); // "hi"
```

var 的声明提升：

1. 对于每个作用域在词法分析阶段就会先挂载好在该作用域上有哪些变量名
2. 但是还没有在真正执行到定义变量的那一行的时候变量名对应的值是 undefined

var 声明的变量全局声明会导致该变量成为全局对象 window 的属性

```js
function foo() {
  console.log(age);
  var age = 26;
}
foo(); // undefined
```

var 反复声明一个变量不会报错

### let

let 和 var 最大的区别是，var 声明的是函数作用域，而 let 声明块级作用域，且 let 不允许重复声明

```js
if (true) {
  var name = "Matt";
  console.log(name); // Matt
}
console.log(name); // Matt
if (true) {
  let age = 26;
  console.log(age); // 26
}
console.log(age); // ReferenceError: age 没有定义
```

let 的暂时性死区：

1. let 没有作用域提升
2. 词法分析阶段一样会把变量名挂到对应作用域上面
3. 但是 let 变量在真正执行到定义的那行之前不允许使用，这就是暂时性死区

```js
// name 会被提升
console.log(name); // undefined
var name = "Matt";
// age 不会被提升
console.log(age); // ReferenceError：age 没有定义
let age = 26;
```

let 全局声明不会被挂到全局对象 window 上

for 循环中 let 声明和 var 声明的区别：

1. var 没有块级作用域，所以 for 循环之后 var 声明的 i 还会存在
2. var 在 for 循环里面是同一个变量，因此 setTimeout 输出的是 5 个 5
3. let 具有块级作用域，出了 for 循环就是没有定义
4. 每一次 for 循环的迭代都是新的块级作用域，也就是会有 5 个 let i，setTimeout 输出是 0 1 2 3 4

```js
for (var i = 0; i < 5; i++) {
  console.log(i);
} // 0 1 2 3 4
console.log("-------");
for (let i = 0; i < 5; i++) {
  console.log(i);
} // 0 1 2 3 4
console.log("-------");
for (var i = 0; i < 5; i++) {
  setTimeout(() => console.log(i), 0);
} // 5 5 5 5 5
console.log("-------");
for (let i = 0; i < 5; i++) {
  setTimeout(() => console.log(i), 0);
} // 0 1 2 3 4
```

### const

最好变量的都使用 const 声明，const 和 let 的区别主要在于 const 被定义后就不允许重新赋值了

## 数据类型

typeof 操作符：typeof 变量：

1.  "undefined"表示值未定义
2.  "boolean"表示值为布尔值
3.  "string"表示值为字符串
4.  "number"表示值为数值
5.  "object"表示值为对象（而不是函数）或 null
6.  "function"表示值为函数
7.  "symbol"表示值为符号

### Undefined

没有显示在定义的时候赋值的都会初始化为 undefined，在逻辑语句里面会类型转换为 false

### Null

1. 逻辑上是空指针的含义，所以 typeof 一个 null 会返回"object"
2. 和 undefined 用途不同，永远不需要显式的赋值 undefined
3. 在要保存对象但是还没有实例可以保存的时候应该保存 null

### Boolean

js 中的 5 个 falsy 值（即做逻辑运算的时候会被转换为 false 的值）：

1. 0
2. NaN
3. ""
4. null
5. undefined

除开以上的 5 个 falsy 值，其他值在做逻辑运算的时候都被当作 true

### Number

JS 中的 Number 就是 IEEE754 标准浮点数，和 c/c++中的 double 相同

值的范围：

1. 最小值 Number.MIN_VALUE，最大值 Number.MAX_VALUE
2. 无穷大用 Infinity 和-Infinity 表示，确定一个数是不是无穷大可以使用 isFinite()函数
3. 特殊值 NaN 表示非数值，NaN 不等于 NaN，逻辑运算返回 false

数值转换（Number()函数）：

1. Boolean true->1 false->0
2. 数值直接返回
3. null -> 0
4. undefined -> NaN
5. 字符串则适用字符串的转化规则
6. parseInt()参数是字符串，转换为整数，第个参数可以输入字符串按什么进制理解
7. parseFloat()参数是字符串，转换为浮点数，始终忽略字符串开头的零

### String

js 中表示字符串的方式：

1. ''包裹
2. ""包裹
3. \`\`包裹，标签模板字符串，可以使用${}来插入表达式

js 中字符串是不可变的，可以通过[]像数组一样访问，但不允许修改值

将值转换为字符串的 toString()方法，不需要参数，该方法在于数值、布尔值、对象和字符串值上可以使用，toString()传入参数的情况是 number 类型转换为字符串时转换成什么进制的字符串输出

```js
let age = 11;
let ageAsString = age.toString(); // 字符串"11"
let found = true;
let foundAsString = found.toString(); // 字符串"true"
let num = 10;
console.log(num.toString()); // "10"
console.log(num.toString(2)); // "1010"
console.log(num.toString(8)); // "12"
console.log(num.toString(10)); // "10"
console.log(num.toString(16)); // "a"
```

模板字符串调用函数：标签函数（tag function）

1. 原始字符串会被理解为第一个参数
2. 所有的${}插值按顺序理解为后面的参数

```JS
let a = 6;
let b = 9;
function simpleTag(strings, aValExpression, bValExpression, sumExpression) {
 console.log(strings);
 console.log(aValExpression);
 console.log(bValExpression);
 console.log(sumExpression);
 return 'foobar';
}
let untaggedResult = `${ a } + ${ b } = ${ a + b }`;
let taggedResult = simpleTag`${ a } + ${ b } = ${ a + b }`;
// ["", " + ", " = ", ""]
// 6
// 9
// 15
console.log(untaggedResult); // "6 + 9 = 15"
console.log(taggedResult); // "foobar"
```

### Symbol

Symbol（符号）是 ECMAScript 6 新增的数据类型。符号是原始值，且符号**实例是唯一、不可变**的。
符号的用途是确保对象属性使用唯一标识符，**不会发生属性冲突**的危险

1. 通过 Symbol()初始化一个 Symbol 值，不可以使用 new Symbol()
2. Symbol()可以接受一个字符串作为 description，将来可以使用这个字符串来调试代码，但与符号定义或标识完全无关
3. symbol 没有字面量语法

### Object

Object在JS当中用作其他类型的基类(即原型链的最后一层)

每一个Object实例上都有的方法和属性：
1. constructor
2. hasOwnProperty(propertyName) 用于判断当前实例（不是原型）上有没有给定的属性（属性名必须是字符串）
3. isPrototypeOf(object) 用于判断当前对象是否是参数对象的原型
4. propertyIsEnumerable(propertyName) 用于判断给定的属性是否可以使用
5. toLocaleString() 返回对象的字符串表示，该字符串反映对象所在的本地化执行环境
6. toString() 返回对象的字符串表示
7. valueOf() 返回对象对应的字符串、数值或布尔值表示

## 操作符

位运算：js当中number都按照IEEE754存储，64位浮点数。但在做位运算的时候会先把数字转换为32位的整数，做完位运算再转回64位浮点数
1. `~` 按位非
2. `|`
3. `&`
4. `^`
5. `>>`
6. `<<`


指数操作符： `**`，和Math.pow()等价，而且也有`**=`

等于`==`和不等于`!=`，有比较复杂的类型转换规则，在对比前先做类型转换

全等`===`和全不等`!==`，不会做类型转换，同时会比较值和数据类型

## 语句

for-in: 用于迭代对象中可枚举属性（Symbol属性不会被枚举）
```js
for (const propertyName of obj) {
  console.log(propertyName)
}
```
for-of: 用来迭代可迭代对象（实现了迭代器），for-of 循环会按照可迭代对象的next()方法产生值的顺序迭代元素
```js
for (const el of [0, 1, 2, 3]) {
  console.log(el);
}
```

with: 用来将代码的作用域限制在特定对象
```js
let qs = location.search.substring(1); 
let hostName = location.hostname; 
let url = location.href;
// 使用with可以将代码的作用域限制在location
with(location) {  
  let qs = search.substring(1); 
  let hostName = hostname; 
  let url = href; 
}
```

## 函数

严格模式下对函数的限制：
1. 函数不能以eval 或arguments 作为名称
2. 函数的参数不能叫eval 或arguments
3. 两个命名参数不能拥有同一个名称